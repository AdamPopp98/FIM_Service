import crypto from 'crypto';
import CryptoJS from 'crypto-js';
import * as funcs from './netcoms.js';

testJsonSendAndReceive();

export function testJsonSendAndReceive()
{
    console.log("Now testing the netcoms.js module...\n\n");

    var hashBuffer = crypto.createHash('sha256')
        .update('This is my secret hash value, please dont tell it to anyone.')
        .digest();

    var domain = "www.umbc.edu";

    //This random buffer will be used as the AES encryption key.
    var randBuffer = crypto.randomBytes(32);

    var time = new Date().valueOf();

    /*
    The challenge is generated by xoring the fresh AES key generated by the server 
    with the secret hash shared by the user's mobile app and the server.
    It is safe to send this in the clear since it will be fersh and highly entropic,
    and the AES key can only be derived with knowledge of the secret hash.
    */
    var challenge = funcs.generateChallenge(hashBuffer, randBuffer);

    /*
    The server packages the challenge and other useful info into a json object.
    This json then gets sent to the user's mobile application.
    */
    var json = funcs.createJsonObject(domain, time, challenge);

    /*
    This plaintext is what the server expects to receive once it decrypts the ciphertext sent back by the user.
    If the cipher text does not decrypt to this using the freshly generated AES key,
    then the server knows that the response was sent by an imposter.
    */
    var plaintext = JSON.stringify(json);

    /*
    Once the user's mobile app receives the plaintext message from the server,
    It derives the AES key by xoring the challenge with the secret hash.
    An imposter cannot derive this key since they do not have the secret hash.
    */
    var derivedKey = funcs.deriveAesKey(hashBuffer, json.challenge);

    /*
    The user's mobile app encrypts the plaintext it received from the server using the key it derived.
    This encrypted ciphertext is then sent back to the server.
    */
    var cipherText = CryptoJS.AES.encrypt(plaintext, derivedKey.toString('hex'))
        .toString();

    /*
    Once the server receives the cipher text is received by the server it attempts to decrypt it. If an imposter sent it with an incorrect AES key it will not decrypt properly.
    Furthermore a man in the middle will not be able to decrypt a response encrypted with the correct key since they can only determine the key by knowing the secret hash.
    */
    var decryptedText = CryptoJS.AES.decrypt(cipherText, randBuffer.toString('hex'))
        .toString();
    
    //This is just the server getting the response from the user's mobile app back into the proper format.
    decryptedText = funcs.hexToAscii(decryptedText);
    decryptedText = JSON.parse(decryptedText);
    decryptedText = JSON.stringify(decryptedText);
    

    console.log("This is what gets sent by the server to the user's mobile app:");
    console.log(plaintext);
    
    console.log("\nThis is what the user sends back to the server:");
    console.log(cipherText);

    console.log("\nThis is the what the server gets when it decrypts the ciphertext:");
    console.log(decryptedText + "\n");

    if (plaintext != decryptedText)
    {
        console.log("TEST FAILED: Plaintext sent by the server does not decrypt back to itself when the ciphertext sent back by the user is decrypted.");
        return;
    }
    console.log("TEST PASSED: Plaintext sent by the server decrypts back to itself when the ciphertext sent back by the user is decrypted.");
}